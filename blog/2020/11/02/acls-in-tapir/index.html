<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Type driven REST API endpoints using Scala and Tapir · Unfold</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In a previous post, I have discussed at length _why_ in order to grow a mature API driven product, we also need a mechanism"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Type driven REST API endpoints using Scala and Tapir · Unfold"/><meta property="og:type" content="website"/><meta property="og:url" content="https://afiore.github.io/website/blog/2020/11/02/acls-in-tapir"/><meta property="og:description" content="In a previous post, I have discussed at length _why_ in order to grow a mature API driven product, we also need a mechanism"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/website/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://afiore.github.io/website/blog/atom.xml" title="Unfold Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://afiore.github.io/website/blog/feed.xml" title="Unfold Blog RSS Feed"/><script src="/website/js/scrollSpy.js"></script><link rel="stylesheet" href="/website/css/main.css"/><script src="/website/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/website/"><img class="logo" src="/website/img/favicon.ico" alt="Unfold"/><h2 class="headerTitleWithLogo">Unfold</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/website/docs/about" target="_self">About me</a></li><li class="siteNavGroupActive"><a href="/website/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/website/blog/2020/11/02/acls-in-tapir">Type driven REST API endpoints using Scala and Tapir</a></li><li class="navListItem"><a class="navItem" href="/website/blog/2020/02/15/discarding-io">Discarded effects: a common pitfall when working with Scala IO monads</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/website/blog/2020/11/02/acls-in-tapir">Type driven REST API endpoints using Scala and Tapir</a></h1><p class="post-meta">November 2, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/afiore" target="_blank" rel="noreferrer noopener">Andrea Fiore</a></p></div></header><div><span><p>In a previous post, I have discussed at length <em>why</em> in order to grow a mature API driven product, we also need a mechanism
to keep API documentation and implementations in sync. It’s now time for me to illustrate <em>how</em> such
a mechanism might look like in the backend; so let's get our hands dirty and write some code!</p>
<p>In this post, I will use Tapir - an excellent open source library maintained by Softwaremill - to demonstrate
how such a <em>code first</em> approach can be implemented in a Scala codebase.</p>
<p>The plan is to work our way through building a couple of REST endpoints for managing Kafka ACLs.
For the sake of simplicity, we will only be creating and listing ACL rules; which is only a subset of all the operations we
would need for a complete API. Also, we will deliberately gloss over the actual persistence of the ACL rules into an actual datastore
(e.g. Zookeeper or similar), and we will simply store them in-memory. Similarly, while I will briefly cover how Tapir can handle authentication and authorisation, for simplicitly I will leave this unimplemented in most of my code samples.</p>
<h3><a class="anchor" aria-hidden="true" id="modelling-our-api-entities"></a><a href="#modelling-our-api-entities" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modelling our API entities</h3>
<p>Kafka ACLs (Access control lists) are a built-in authorisation mechanism whereby administrators can control access to a cluster’s data. In a nutshell, a Kafka <em>ACL binding</em> comprises of the following key attributes:</p>
<ul>
<li>A <em>resource</em> on which to perform some sort of operation</li>
<li>The <em>operation</em> itself (which varies, depending on the resource)</li>
<li>A <em>principal</em> (i.e. the entity to be authorised)</li>
<li>A permission type (i.e. can be either <code>Allow</code> or <code>Deny</code>)</li>
</ul>
<p>In Scala, we would model acls as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> io.circe.generic.semiauto.deriveCodec
<span class="hljs-keyword">import</span> io.circe.<span class="hljs-type">Codec</span>

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcePattern</span>(<span class="hljs-params">resourceType: <span class="hljs-type">ResourceType</span>,
                                 resource: <span class="hljs-type">String</span>,
                                 patternType: <span class="hljs-type">PatternType</span></span>)</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ResourcePattern</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">ResourcePattern</span>] = deriveCodec
}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclEntry</span>(<span class="hljs-params">principal: <span class="hljs-type">String</span>,
                          host: <span class="hljs-type">String</span>,
                          operation: <span class="hljs-type">Operation</span>,
                          permissionType: <span class="hljs-type">PermissionType</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEntry</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">AclEntry</span>] = deriveCodec
}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclBinding</span>(<span class="hljs-params">pattern: <span class="hljs-type">ResourcePattern</span>, entry: <span class="hljs-type">AclEntry</span></span>)</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclBinding</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">AclBinding</span>] = deriveCodec
}
</code></pre>
<p>Here we define an immutable record type called <code>AclBinding</code>; in Scala parlance, a case class. This wraps a resource
<code>pattern</code> and an <code>entity</code>, which combined represent an ACL authorisation rule (please refer to the <a href="https://kafka.apache.org/25/javadoc/">Kafka 2.5 Javadoc</a>
for the possible values of enumerables such us <code>ResourceType</code>, <code>PatternType</code>, or <code>Operation</code>). This is the only entity our API will revolve around, and here is how we can define some sample values:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Examples</span> </span>{
  <span class="hljs-keyword">val</span> validAcl1 = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>, <span class="hljs-string">"position-report"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">LITERAL</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"User:andrea"</span>, <span class="hljs-string">"example.cloud"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">ALL</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

  <span class="hljs-keyword">val</span> validAcl2 = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">CLUSTER</span>, <span class="hljs-string">"kafka-test-"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">PREFIXED</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"Group:testers"</span>, <span class="hljs-string">"example.cloud1"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">DESCRIBE</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

  <span class="hljs-keyword">val</span> invalidAcl = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TRANSACTION_ID</span>, <span class="hljs-string">"*"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">LITERAL</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"User:andrea"</span>, <span class="hljs-string">"cloud1"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">ALTER</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

}
</code></pre>
<p>Now, let's move on to defining a REST endpoint to create a Kafka ACL!</p>
<h3><a class="anchor" aria-hidden="true" id="strongly-typed-endpoint-definitions"></a><a href="#strongly-typed-endpoint-definitions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongly typed endpoint definitions</h3>
<p>In Tapir, REST endpoints are described as values of type <code>Endpoint[I, E, O, S]</code> where:</p>
<ul>
<li><code>I</code> is a <em>tuple</em> representing the various endpoint inputs (e.g. dynamic path fragments, query params, as well as its parsed request payload).</li>
<li><code>E</code> and <code>O</code> are output types for the error (e.g. 400 Bad Request) and the success (2xx) case.</li>
<li><code>S</code> is the type of streams that are used by the endpoint’s inputs/outputs. This is relevant only for more advanced use
cases such as defining Server Sent Events and Websocket endpoints, which we will not be covering in this post.</li>
</ul>
<p>In order to declare such complex type definitions, the library provides us with a builder syntax that allows us to incrementally declare our endpoint's inlets and outlets bit by bit, with great degree of precision:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.generic.auto._
<span class="hljs-keyword">import</span> sttp.tapir.json.circe._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">StatusCode</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEndpoints</span> </span>{
    <span class="hljs-keyword">val</span> createNewAcl: <span class="hljs-type">Endpoint</span>[(<span class="hljs-type">AuthToken</span>, <span class="hljs-type">AclBinding</span>), <span class="hljs-type">ApiError</span>, <span class="hljs-type">Unit</span>, <span class="hljs-type">Nothing</span>] = endpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(jsonBody[<span class="hljs-type">AclBinding</span>])
      .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))
}
</code></pre>
<p>There's quite a lot going on here already, so let's start unpacking it bit by bit:</p>
<p>We start building the endpoint using the constructor value <code>endpoint</code> of type <code>Enpoint[Unit, Unit, Unit, Nothing]</code>.
This acts as the entry point into the Tapir DSL. Using such syntax, we also specify that:</p>
<ul>
<li>Our endpoint's uses the http method <code>POST</code></li>
<li>it will be bound to the path <code>/api/kafka/acls</code></li>
<li>it will expect a header called <code>x-api-token</code> as well as a JSON request body (parsable as <code>AclBinding</code>) as its input</li>
<li>On success, it will respond with a status code of <code>201 Created</code> and an empty response payload.</li>
<li>On error, it will respond with the JSON representation of an <code>ApiError</code>.</li>
</ul>
<p>With our first endpoint defined in all its nitty gritty details, it's now time move on and implement the underlying logic.
But first, let's quickly flash out another endpoint to list the persisted Acls:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.generic.auto._
<span class="hljs-keyword">import</span> sttp.tapir.json.circe._
<span class="hljs-keyword">import</span> sttp.tapir.codec.enumeratum._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">StatusCode</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEndpoints</span> </span>{
    <span class="hljs-keyword">val</span> createNewAcl = endpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(jsonBody[<span class="hljs-type">AclBinding</span>].description(<span class="hljs-string">"The json representation of an ACL binding"</span>).example(<span class="hljs-type">Examples</span>.validAcl1))
      .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))


    <span class="hljs-keyword">val</span> listAllAcls = endpoint
      .get
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(query[<span class="hljs-type">Option</span>[<span class="hljs-type">ResourceType</span>]](<span class="hljs-string">"resourceType"</span>)
           .description(<span class="hljs-string">"An optional ResourceType value to filter by"</span>)
           .example(<span class="hljs-type">Some</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>)))
      .out(jsonBody[<span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]])
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="wiring-up-our-business-logic"></a><a href="#wiring-up-our-business-logic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wiring up our business logic</h3>
<p>As mentioned before, we plan on stubbing the persistence of our ACL bindings into a in-memory structure.
However, in order to do so we will still need to rely on a real HTTP server capable of handling incoming client
requests.</p>
<p>For this post, I have chosen to use http4s, a library that allows to work with HTTP in a <em>purely functional</em> style.
Please do not run away if this is not your library of choice. As well as for http4s, Tapir provides support for several other
Scala HTTP server implementations such us Akka-HTTP, Play, Finatra, and Vert.X.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.server.http4s._
<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> org.http4s.<span class="hljs-type">HttpRoutes</span>
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>}
<span class="hljs-keyword">import</span> cats.effect.concurrent.<span class="hljs-type">Ref</span>
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclRoutes</span>(<span class="hljs-params">aclStore: <span class="hljs-type">Ref</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">AclBinding</span>]]</span>)(<span class="hljs-params">implicit cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>], timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>]</span>) </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> createNewAcl: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] =
    <span class="hljs-type">AclEndpoints</span>.createNewAcl.toRoutes { <span class="hljs-keyword">case</span> (_, aclBinding) =&gt; 
       <span class="hljs-keyword">if</span> (!<span class="hljs-type">AclValidation</span>.isValid(aclBinding)) <span class="hljs-type">IO</span>.pure(<span class="hljs-type">Left</span>(<span class="hljs-type">AclValidation</span>.<span class="hljs-type">Error</span>))
       <span class="hljs-keyword">else</span> aclStore.update(_ + aclBinding).map(_ =&gt; <span class="hljs-type">Right</span>(()))
    }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> listAcls: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] =
    <span class="hljs-type">AclEndpoints</span>.listAllAcls.toRoutes { <span class="hljs-keyword">case</span> (_, maybeResourceType) =&gt; 
      <span class="hljs-keyword">val</span> matchesResourceType: <span class="hljs-type">AclBinding</span> =&gt; <span class="hljs-type">Boolean</span> = acl =&gt; maybeResourceType.fold(<span class="hljs-literal">true</span>)(acl.pattern.resourceType == _)
      aclStore.get.map(_.toList.filter(matchesResourceType).asRight[<span class="hljs-type">Unit</span>])
    }

  <span class="hljs-keyword">val</span> combined: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] = createNewAcl &lt;+&gt; listAcls
}
</code></pre>
<p>To start with, notice the <code>sttp.tapir.server.http4s._</code> import. This brings in a bunch of implicit
classes that extend our <code>Endpoint[_,...]</code> with a <code>toRoutes</code> method. <code>toRoutes</code> <em>interprets</em> the Tapir
endpoint description into a <code>org.http4.HttpRoutes[IO]</code> (i.e. the actual HTTP server implementation).
Also, notice how the input, error and output types of the two routes are fully aligned with the ones of our endpoint
definitions. It is by this aliment mechanism that the library provides us with strong compile-time guarantess that
our implementation won't drift away from the generated docs, and that our system <em>will do exactly what it says on the tin</em>.</p>
<p>Let's now look at the two route implementations. In <code>createNewAcl</code>, we pass the parsed payload <code>aclBinding</code> as an input for <code>AclValidation.isValid</code>.
For simplicity, I am omitting the actual implementation of the <code>AclValidation</code> object. For the sake of example, let's say that <code>isValid</code> performs some simple logic to verify
that the supplied combination of our Acl's <code>ResourceType</code> and <code>Operation</code> is valid as per the <a href="https://docs.confluent.io/platform/current/kafka/authorization.html#operations">reference table</a>
in the Confluent docs. If the validation succeeds and a <code>Right(())</code> is returned, we
simply update our in memory store by adding the new acl binding. If the validation fails, we instead return
a <code>Left</code> wrapping an <code>ApiError</code> value.</p>
<p>The implementation of <code>listAcls</code> is equally simple. Here we read from our store, apply an optional <code>ResourceType</code> filter, and return the resulting set of acls as a list.
Unlike with the <code>createNewAcl</code>, we don't expect this endpoint to ever return a <code>Bad Request</code>, so we type its error as <code>Unit</code>.</p>
<p>Aside from reading and writing to the atomic reference <code>aclStore</code>, our ACL handling code here is pretty much pure and side-effect free. However,
Tapir models the logic used to interpret the endpoint into an actual route as a function of the followign shape: <code>I =&gt; IO[Either[E, O]</code>, or more generically <code>I =&gt; F[Either[E, O]</code>.
This makes sense, as most read world API endpoints perform some sort of effectful computation such us opening sockets, interacting with a datastore, or reading/writing to disk.</p>
<h3><a class="anchor" aria-hidden="true" id="authentication-and-other-common-route-logic"></a><a href="#authentication-and-other-common-route-logic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Authentication and other common route logic</h3>
<p>While in the endpoint definitions above we do specify an <code>x-api-token</code> header, you might have noticed that we haven't yet
implemented any logic around this mandatory input. As it currently stands, our server logic is in fact completely insecure, and we should probably do something about it!</p>
<p>One simple way to approach this would be to implement an authentication helper function like the following and reuse it across all the endpoints we want to secure:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">userOrApiError</span></span>[<span class="hljs-type">A</span>](token: <span class="hljs-type">ApiToken</span>)(logic: <span class="hljs-type">User</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[]]): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">A</span>]]
</code></pre>
<p>For instance, we would extend the <code>createNewAcl</code> route as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">AclEndpoints</span>.createNewAcl.toRoutes { <span class="hljs-keyword">case</span> (apiToken, aclBinding) =&gt; 
   userOrApiError(apiToken) { user =&gt;
     <span class="hljs-keyword">if</span> (!<span class="hljs-type">AclValidation</span>.isValid(aclBinding)) <span class="hljs-type">IO</span>.pure(<span class="hljs-type">Left</span>(<span class="hljs-type">AclValidation</span>.<span class="hljs-type">Error</span>))
     <span class="hljs-keyword">else</span> aclStore.update(_ + aclBinding).map(_ =&gt; <span class="hljs-type">Right</span>(()))
   }
}
</code></pre>
<p>This might look okay in a small codebase like ours, but it will probably not fly on a large
one, as the boilerplate and the nesting of helper functions like <code>userOrApiError</code> will increase as
our cross-cutting concerns become more complex and involved.</p>
<p>Lukily, the authors of Tapir have recently come up with a nicer pattern to handle common logic such as
authentication and authorisation. This revolves around the notion of partially defined endpoints which can combine
an input/output description with some server logic:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SecureAclEndpoints</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auth</span></span>(token: <span class="hljs-type">AuthToken</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">User</span>]] = <span class="hljs-type">IO</span>.pure {
    <span class="hljs-keyword">if</span> (token == <span class="hljs-string">"let-me-in!"</span>) <span class="hljs-type">Right</span>(<span class="hljs-type">User</span>(<span class="hljs-string">"legit"</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-type">Left</span>(<span class="hljs-type">ApiError</span>(<span class="hljs-string">"Forbidden"</span>))
  }
  
  <span class="hljs-keyword">val</span> secureEndpoint = endpoint
    .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-auth-token"</span>))
    .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
    .serverLogicForCurrent(auth)
}
</code></pre>
<p>Both the endpoint definition and the server logic in <code>secureEndpoint</code> can now be neatly composed into other
definitions:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> createNewAcl = <span class="hljs-type">SecureAclEndpoints</span>
      .secureEndpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(jsonBody[<span class="hljs-type">AclBinding</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))
<span class="hljs-comment">// createNewAcl: server.PartialServerEndpoint[User, AclBinding, ApiError, typelevel.LowPriorityTupleConcat0.&lt;refinement&gt;.this.type.Out, Any, IO] = sttp.tapir.server.PartialServerEndpoint$$anon$1@2d480606</span>
</code></pre>
<p>For more details on partial endpoints and other ways in which Tapir allows to abstract common logic, please refer to the
the <a href="https://tapir.softwaremill.com/en/v0.16.16/server/logic.html">Server Logic</a> section of the official docs.</p>
<h3><a class="anchor" aria-hidden="true" id="hitting-our-endpoints"></a><a href="#hitting-our-endpoints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hitting our endpoints</h3>
<p>Okay, so we have a couple of endpoints defined and implemented. Now we should probably check that they work as expected.
One way to do so without having to bind an actual web server to a port is to use http4s DSL and hit our routes programmatically, as we would do in a simple unit test covering only the route logic.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> cats.effect.concurrent.<span class="hljs-type">Ref</span>
<span class="hljs-keyword">import</span> org.http4s.<span class="hljs-type">HttpRoutes</span>
<span class="hljs-keyword">import</span> org.http4s.dsl.io._
<span class="hljs-keyword">import</span> org.http4s.headers._
<span class="hljs-keyword">import</span> org.http4s._
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>}
<span class="hljs-keyword">import</span> org.http4s.circe._
<span class="hljs-keyword">import</span> org.http4s.implicits._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] =
  <span class="hljs-type">IO</span>.contextShift(scala.concurrent.<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> t: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>] =
  <span class="hljs-type">IO</span>.timer(scala.concurrent.<span class="hljs-type">ExecutionContext</span>.global)  

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> aclEntityEncoder = jsonEncoderOf[<span class="hljs-type">IO</span>, <span class="hljs-type">AclBinding</span>]
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> aclEntityDecoder = jsonOf[<span class="hljs-type">IO</span>, <span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]]
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> apiEntityDecoder = jsonOf[<span class="hljs-type">IO</span>, <span class="hljs-type">ApiError</span>]

<span class="hljs-keyword">val</span> apiToken = <span class="hljs-type">Header</span>(<span class="hljs-string">"x-api-token"</span>, <span class="hljs-string">"let-me-in!"</span>)
<span class="hljs-keyword">val</span> endpointUrl = <span class="hljs-type">Uri</span>.unsafeFromString(<span class="hljs-string">"/api/kafka/acls"</span>)

<span class="hljs-keyword">val</span> store = <span class="hljs-type">Ref</span>.unsafe[<span class="hljs-type">IO</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">AclBinding</span>]](<span class="hljs-type">Set</span>.empty)
<span class="hljs-keyword">val</span> routes = <span class="hljs-keyword">new</span> <span class="hljs-type">AclRoutes</span>(store).combined.orNotFound
</code></pre>
<p>Here we just setup the boilerplate needed to run some HTTP request through our web service:
We initialise a store and the AclRoutes, and then we compose the two routes
above into a single http service which will fallback to a 404 response should it fail to match
the incoming request. With some help from the http4s DSL, we can now fire a few requests
at our endpoints!</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">//create a valid ACL binding</span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">POST</span>, endpointUrl)
    .withHeaders(apiToken)
    .withEntity(<span class="hljs-type">Examples</span>.validAcl1)
).map(_.status).unsafeRunSync()
<span class="hljs-comment">// res0: Status = Status(code = 201)</span>

<span class="hljs-comment">//try to submit an invalid one</span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">POST</span>, endpointUrl)
    .withHeaders(apiToken)
    .withEntity(<span class="hljs-type">Examples</span>.invalidAcl)
).flatMap(resp =&gt; resp.as[<span class="hljs-type">ApiError</span>].map(_ -&gt; resp.status)).unsafeRunSync()
<span class="hljs-comment">// res1: (ApiError, Status) = (</span>
<span class="hljs-comment">//   ApiError(error = "The supplied ACL binding is invalid"),</span>
<span class="hljs-comment">//   Status(code = 400)</span>
<span class="hljs-comment">// )</span>

<span class="hljs-comment">//Get the acl list </span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">GET</span>, endpointUrl.withQueryParam(<span class="hljs-string">"resourceType"</span>, <span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>.entryName))
    .withHeaders(apiToken)
).flatMap(_.as[<span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]]).unsafeRunSync()
<span class="hljs-comment">// res2: List[AclBinding] = List(</span>
<span class="hljs-comment">//   AclBinding(</span>
<span class="hljs-comment">//     pattern = ResourcePattern(</span>
<span class="hljs-comment">//       resourceType = TOPIC,</span>
<span class="hljs-comment">//       resource = "position-report",</span>
<span class="hljs-comment">//       patternType = LITERAL</span>
<span class="hljs-comment">//     ),</span>
<span class="hljs-comment">//     entry = AclEntry(</span>
<span class="hljs-comment">//       principal = "User:andrea",</span>
<span class="hljs-comment">//       host = "example.cloud",</span>
<span class="hljs-comment">//       operation = ALL,</span>
<span class="hljs-comment">//       permissionType = ALLOW</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Hurray! Our endpoints seem to work as expected.</p>
<h3><a class="anchor" aria-hidden="true" id="interpreting-into-an-openapi-spec"></a><a href="#interpreting-into-an-openapi-spec" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interpreting into an OpenAPI spec</h3>
<p>With both endpoint declartion, implementation and testing covered, we are finally ready to look into
how Tapir helps us writing and maintaining high quality API docs. This is surprisingly straightfoward
as it only involves grouping our endpoint definitions into a sequence and use a simple DSL to build an OpenAPI
spec: a machine readable specification detailing all the relevant attributes of our endpoints, from the query paramters
to the JSON schema of the request/response payloads.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.openapi.<span class="hljs-type">OpenAPI</span>
<span class="hljs-keyword">import</span> sttp.tapir.docs.openapi._

<span class="hljs-keyword">val</span> openAPISpec = <span class="hljs-type">List</span>(
  <span class="hljs-type">AclEndpoints</span>.createNewAcl,
  <span class="hljs-type">AclEndpoints</span>.listAllAcls
).toOpenAPI(<span class="hljs-string">"REST Kafka ACLs"</span>, <span class="hljs-string">"1.0"</span>)
<span class="hljs-comment">// openAPISpec: OpenAPI = OpenAPI(</span>
<span class="hljs-comment">//   openapi = "3.0.3",</span>
<span class="hljs-comment">//   info = Info(</span>
<span class="hljs-comment">//     title = "REST Kafka ACLs",</span>
<span class="hljs-comment">//     version = "1.0",</span>
<span class="hljs-comment">//     description = None,</span>
<span class="hljs-comment">//     termsOfService = None,</span>
<span class="hljs-comment">//     contact = None,</span>
<span class="hljs-comment">//     license = None</span>
<span class="hljs-comment">//   ),</span>
<span class="hljs-comment">//   tags = List(),</span>
<span class="hljs-comment">//   servers = List(),</span>
<span class="hljs-comment">//   paths = ListMap(</span>
<span class="hljs-comment">//     "/api/kafka/acls" -&gt; PathItem(</span>
<span class="hljs-comment">//       summary = None,</span>
<span class="hljs-comment">//       description = None,</span>
<span class="hljs-comment">//       get = Some(</span>
<span class="hljs-comment">//         value = Operation(</span>
<span class="hljs-comment">//           tags = List(),</span>
<span class="hljs-comment">//           summary = None,</span>
<span class="hljs-comment">//           description = None,</span>
<span class="hljs-comment">//           operationId = "getApiKafkaAcls",</span>
<span class="hljs-comment">//           parameters = List(</span>
<span class="hljs-comment">//             Right(</span>
<span class="hljs-comment">//               value = Parameter(</span>
<span class="hljs-comment">//                 name = "x-api-token",</span>
<span class="hljs-comment">//                 in = header,</span>
<span class="hljs-comment">//                 description = None,</span>
<span class="hljs-comment">//                 required = Some(value = true),</span>
<span class="hljs-comment">//                 deprecated = None,</span>
<span class="hljs-comment">//                 allowEmptyValue = None,</span>
<span class="hljs-comment">//                 style = None,</span>
<span class="hljs-comment">//                 explode = None,</span>
<span class="hljs-comment">//                 allowReserved = None,</span>
<span class="hljs-comment">//                 schema = Right(</span>
<span class="hljs-comment">//                   value = Schema(</span>
<span class="hljs-comment">//                     allOf = List(),</span>
<span class="hljs-comment">//                     title = None,</span>
<span class="hljs-comment">//                     required = List(),</span>
<span class="hljs-comment">//                     type = Some(value = string),</span>
<span class="hljs-comment">//                     items = None,</span>
<span class="hljs-comment">//                     properties = ListMap(),</span>
<span class="hljs-comment">//                     description = None,</span>
<span class="hljs-comment">//                     format = None,</span>
<span class="hljs-comment">//                     default = None,</span>
<span class="hljs-comment">//                     nullable = None,</span>
<span class="hljs-comment">//                     readOnly = None,</span>
<span class="hljs-comment">//                     writeOnly = None,</span>
<span class="hljs-comment">//                     example = None,</span>
<span class="hljs-comment">// ...</span>
</code></pre>
<p>Notice that the value returned by <code>toOpenAPI</code> is a syntax tree modelling an OpenAPI spec. Once computed,
this syntax tree can be modified and extended using plain scala functions. Most of the times, this is something you will
not need doing, but it can provide a good escape hatch should you need to produce OpenAPI specs in a way that for some reason
Tapir doesn't support.</p>
<p>As a final step, you will probably want to serialise the spec into YAML so that it can be exported or served to the browser
as an HTTP response:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir.openapi.circe.yaml._

println(openAPISpec.toYaml)
<span class="hljs-comment">// openapi: 3.0.3</span>
<span class="hljs-comment">// info:</span>
<span class="hljs-comment">//   title: REST Kafka ACLs</span>
<span class="hljs-comment">//   version: '1.0'</span>
<span class="hljs-comment">// paths:</span>
<span class="hljs-comment">//   /api/kafka/acls:</span>
<span class="hljs-comment">//     get:</span>
<span class="hljs-comment">//       operationId: getApiKafkaAcls</span>
<span class="hljs-comment">//       parameters:</span>
<span class="hljs-comment">//       - name: x-api-token</span>
<span class="hljs-comment">//         in: header</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//       - name: resourceType</span>
<span class="hljs-comment">//         in: query</span>
<span class="hljs-comment">//         description: An optional ResourceType value to filter by</span>
<span class="hljs-comment">//         required: false</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - CLUSTER</span>
<span class="hljs-comment">//           - DELEGATION_TOKEN</span>
<span class="hljs-comment">//           - GROUP</span>
<span class="hljs-comment">//           - TOPIC</span>
<span class="hljs-comment">//           - TRANSACTION_ID</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//         example: TOPIC</span>
<span class="hljs-comment">//       responses:</span>
<span class="hljs-comment">//         '200':</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//           content:</span>
<span class="hljs-comment">//             application/json:</span>
<span class="hljs-comment">//               schema:</span>
<span class="hljs-comment">//                 type: array</span>
<span class="hljs-comment">//                 items:</span>
<span class="hljs-comment">//                   $ref: '#/components/schemas/AclBinding'</span>
<span class="hljs-comment">//     post:</span>
<span class="hljs-comment">//       operationId: postApiKafkaAcls</span>
<span class="hljs-comment">//       parameters:</span>
<span class="hljs-comment">//       - name: x-api-token</span>
<span class="hljs-comment">//         in: header</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//       requestBody:</span>
<span class="hljs-comment">//         description: The json representation of an ACL binding</span>
<span class="hljs-comment">//         content:</span>
<span class="hljs-comment">//           application/json:</span>
<span class="hljs-comment">//             schema:</span>
<span class="hljs-comment">//               $ref: '#/components/schemas/AclBinding'</span>
<span class="hljs-comment">//             example:</span>
<span class="hljs-comment">//               pattern:</span>
<span class="hljs-comment">//                 resourceType: TOPIC</span>
<span class="hljs-comment">//                 resource: position-report</span>
<span class="hljs-comment">//                 patternType: LITERAL</span>
<span class="hljs-comment">//               entry:</span>
<span class="hljs-comment">//                 principal: User:andrea</span>
<span class="hljs-comment">//                 host: example.cloud</span>
<span class="hljs-comment">//                 operation: ALL</span>
<span class="hljs-comment">//                 permissionType: ALLOW</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//       responses:</span>
<span class="hljs-comment">//         '201':</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//         default:</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//           content:</span>
<span class="hljs-comment">//             application/json:</span>
<span class="hljs-comment">//               schema:</span>
<span class="hljs-comment">//                 $ref: '#/components/schemas/ApiError'</span>
<span class="hljs-comment">// components:</span>
<span class="hljs-comment">//   schemas:</span>
<span class="hljs-comment">//     AclBinding:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - pattern</span>
<span class="hljs-comment">//       - entry</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         pattern:</span>
<span class="hljs-comment">//           $ref: '#/components/schemas/ResourcePattern'</span>
<span class="hljs-comment">//         entry:</span>
<span class="hljs-comment">//           $ref: '#/components/schemas/AclEntry'</span>
<span class="hljs-comment">//     ResourcePattern:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - resourceType</span>
<span class="hljs-comment">//       - resource</span>
<span class="hljs-comment">//       - patternType</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         resourceType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - CLUSTER</span>
<span class="hljs-comment">//           - DELEGATION_TOKEN</span>
<span class="hljs-comment">//           - GROUP</span>
<span class="hljs-comment">//           - TOPIC</span>
<span class="hljs-comment">//           - TRANSACTION_ID</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//         resource:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         patternType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - LITERAL</span>
<span class="hljs-comment">//           - MATCH</span>
<span class="hljs-comment">//           - PREFIXED</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//     AclEntry:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - principal</span>
<span class="hljs-comment">//       - host</span>
<span class="hljs-comment">//       - operation</span>
<span class="hljs-comment">//       - permissionType</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         principal:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         host:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         operation:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - ALL</span>
<span class="hljs-comment">//           - ALTER</span>
<span class="hljs-comment">//           - ALTER_CONFIGS</span>
<span class="hljs-comment">//           - CLUSTER_ACTION</span>
<span class="hljs-comment">//           - CREATE</span>
<span class="hljs-comment">//           - DELETE</span>
<span class="hljs-comment">//           - DESCRIBE</span>
<span class="hljs-comment">//           - DESCRIBE_CONFIGS</span>
<span class="hljs-comment">//           - IDEMPOTENT_WRITE</span>
<span class="hljs-comment">//           - READ</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//           - WRITE</span>
<span class="hljs-comment">//         permissionType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - ALLOW</span>
<span class="hljs-comment">//           - DENY</span>
<span class="hljs-comment">//     ApiError:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - error</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         error:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//</span>
</code></pre>
<p>As a format, OpenAPI is agnostic of its presentation. However, several web-based UI tools exist to browse and interact with
OpenAPI specs. This is how our endpoints look like when viewed in SwaggerUI, one of the most popular OpenAPI viewer:</p>
<p><img src="https://ibin.co/w800/5jSShLatLQ7N.png" alt="endpoints see SwaggerUI"></p>
<h3><a class="anchor" aria-hidden="true" id="interpreting-into-an-api-client"></a><a href="#interpreting-into-an-api-client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interpreting into an API client</h3>
<p>Autogenerating API docs from our endpoint definitions is great, but it doesn't have to end there; we can be more ambitious and automate more agressively!
As well as an OpenAPI spec, Tapir can also <em>interpret</em> an endpoint definition into a fully functioning API client:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir.client.sttp._
<span class="hljs-keyword">import</span> sttp.client3._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">Uri</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclClient</span>(<span class="hljs-params">apiBaseUrl: <span class="hljs-type">Uri</span>, apiToken: <span class="hljs-type">String</span></span>) </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> backend: <span class="hljs-type">SttpBackend</span>[<span class="hljs-type">Identity</span>, <span class="hljs-type">Any</span>] = <span class="hljs-type">HttpURLConnectionBackend</span>()

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createNewAcl</span></span>(aclBinding: <span class="hljs-type">AclBinding</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">Unit</span>]] = {
     <span class="hljs-keyword">val</span> endpointInput = (apiToken, aclBinding)
     <span class="hljs-keyword">val</span> request = <span class="hljs-type">AclEndpoints</span>.createNewAcl.toSttpRequestUnsafe(apiBaseUrl).apply(endpointInput)
     <span class="hljs-type">IO</span>(request.send(backend).body)
   }
}
</code></pre>
<p>The snippet above illustrates how to use Tapir to generate HTTP requests for the Sttp client. The <code>toSttpRequestUnsafe</code>
function brought in by the <code>sttp.tapir.client.sttp</code> import, takes in two parameters:</p>
<ul>
<li>A <code>baseUrl</code> for our API server</li>
<li>The endpoint inputs, as specified in the above definition (in this example, a <code>Touple2</code> containing the api key and the supplied ACL binding).</li>
</ul>
<p>Compared to our previous snippet, where we hit our endpoints using the Http4s DSL, this approach has some significant advantages:
the generated Tapir API client neatly abstracts away the details of the HTTP implementation as well as the serialisation format, exposing only a function that maps our API inputs to its outpus.</p>
<p>Arguably, working at this level of abstraction is for most engineers preferable than having to be
bogged down into the details of hand-wiring HTTP requests. Moreover, it is also safer, as it rules out a
whole class of trivial and yet very frequent programming errors (e.g. mispelling the api key header, omitting part of the ACL JSON payload, etc) while reducing the likelyhood for the client implementation to go out of sync with the server.</p>
<h3><a class="anchor" aria-hidden="true" id="conclusions"></a><a href="#conclusions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusions</h3>
<p>In this post, I have tried to demostrate Tapir's main features by working through the implementation of a REST API
for creating and listing Kafka ACLs. We saw how endpoint definitions, expressed as scala types, can drive the
implementation of both server side logic while at the same time automatically genrate up-to-date
API docs, as well as fully functioning API clients.</p>
<p>Now, before you set off to introduce Tapir in your production code-base, please let me also share a few words of warning:</p>
<p>Firstly, despite its increasingly rich set of features and integrations, keep in mind that Tapir is still a relatively
young project with only a couple of years of active development under his belt. While it is definitly reaching maturity,
I would still expect its API to occasionally introduce somes breaking changes, which might make it harder to retrofit
into a large existing project.</p>
<p>Secondly, like with every software framework, do keep in mind that all the good automation and safety that Tapir brings
about comes at a cost. You will have to face a slightly higher degree of indirection, as the library centralises
control over settings and behaviours that you would otherwise be able to control on a single route/endpoint basis
(e.g. handling of unparsable input payloads, handling of exceptions, etc).</p>
<p>Also, be prepared to dive into some deep Scala rabbit holes, as Tapir leverages advanced features of the language
such as type-level programming, type-class derivation, macros, etc. In other words, this is something you probably want to
stay clear from if you are still familiarising with the language.</p>
<p>That said, if you are not put off by either of the above, this might be a price worth paying in exchange for a higher
degree of API integration, automation and consistency. I hope I have shared with you some of my enthusiasm for this excellent library, as I genuinely belive it makes building complex, API driven systems at scale easier and safer to
a remarkable extent.</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/website/blog/">Recent Posts</a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020 Your Name or Your Company Name</section></footer></div></body></html>