<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · Unfold</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Andrea&#x27;s software engineering notes"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · Unfold"/><meta property="og:type" content="website"/><meta property="og:url" content="https://afiore.github.io/website/"/><meta property="og:description" content="Andrea&#x27;s software engineering notes"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/website/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://afiore.github.io/website/blog/atom.xml" title="Unfold Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://afiore.github.io/website/blog/feed.xml" title="Unfold Blog RSS Feed"/><script src="/website/js/scrollSpy.js"></script><link rel="stylesheet" href="/website/css/main.css"/><script src="/website/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/website/"><img class="logo" src="/website/img/favicon.ico" alt="Unfold"/><h2 class="headerTitleWithLogo">Unfold</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/website/docs/about" target="_self">About me</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/website/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/website/blog/2020/11/02/acls-in-tapir">Type driven API development using Scala and Tapir</a></li><li class="navListItem"><a class="navItem" href="/website/blog/2020/02/15/discarding-io">Discarded effects: a common pitfall when working with Scala IO monads</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/website/blog/2020/11/02/acls-in-tapir">Type driven API development using Scala and Tapir</a></h1><p class="post-meta">November 2, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/afiore" target="_blank" rel="noreferrer noopener">Andrea Fiore</a></p></div></header><article class="post-content"><div><span><p>In a previous post, I have discussed at length <em>why</em>, in order to grow a mature API driven product, we need a mechanism
to keep API documentation and implementations in sync. It’s now time for me to illustrate <em>how</em> such
a mechanism might look like in the backend; so let's get our hands dirty and write some code!</p>
<p>In this post, I will use <a href="https://tapir-scala.readthedocs.io/">Tapir</a> - an excellent open source library by <a href="https://softwaremill.com/">Softwaremill</a> - to demonstrate
a <em><a href="https://swagger.io/blog/api-design/design-first-or-code-first-api-development/">code first</a></em> approach to API development in Scala.</p>
<p>The plan is to work our way through building a couple of REST endpoints for managing Kafka ACLs.
For the sake of simplicity, we will only be creating and listing ACL rules; which is only a subset of all the operations we
would need for a complete API. Also, we will deliberately gloss over the actual persistence of the ACL rules into an actual datastore
(e.g. Zookeeper or similar), and we will simply store them in-memory. Similarly, I will briefly cover how Tapir can handle authentication
and authorisation, but for simplicity I will leave this unimplemented in most of my code samples.</p>
<h3><a class="anchor" aria-hidden="true" id="modelling-our-api-entities"></a><a href="#modelling-our-api-entities" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modelling our API entities</h3>
<p>Kafka ACLs (Access control lists) are a built-in authorisation mechanism whereby administrators can control access to a cluster’s data.
In a nutshell, a Kafka <em>ACL binding</em> comprises of the following key attributes:</p>
<ul>
<li>A <em>resource</em> on which to perform some sort of operation</li>
<li>The <em>operation</em> itself (which varies, depending on the resource)</li>
<li>A <em>principal</em> (i.e. the entity to be authorised)</li>
<li>A permission type (i.e. can be either <code>Allow</code> or <code>Deny</code>)</li>
</ul>
<p>In Scala, we would model acls as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> io.circe.generic.semiauto.deriveCodec
<span class="hljs-keyword">import</span> io.circe.<span class="hljs-type">Codec</span>

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcePattern</span>(<span class="hljs-params">resourceType: <span class="hljs-type">ResourceType</span>,
                                 resource: <span class="hljs-type">String</span>,
                                 patternType: <span class="hljs-type">PatternType</span></span>)</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ResourcePattern</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">ResourcePattern</span>] = deriveCodec
}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclEntry</span>(<span class="hljs-params">principal: <span class="hljs-type">String</span>,
                          host: <span class="hljs-type">String</span>,
                          operation: <span class="hljs-type">Operation</span>,
                          permissionType: <span class="hljs-type">PermissionType</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEntry</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">AclEntry</span>] = deriveCodec
}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclBinding</span>(<span class="hljs-params">pattern: <span class="hljs-type">ResourcePattern</span>, entry: <span class="hljs-type">AclEntry</span></span>)</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclBinding</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> codec: <span class="hljs-type">Codec</span>[<span class="hljs-type">AclBinding</span>] = deriveCodec
}
</code></pre>
<p>Here we define an immutable record type called <code>AclBinding</code>; in Scala parlance, a case class. This wraps a resource
<code>pattern</code> and an <code>entity</code>, which combined represent an ACL authorisation rule (please refer to the <a href="https://kafka.apache.org/25/javadoc/">Kafka 2.5 Javadoc</a>
for the possible values of enumerables such us <code>ResourceType</code>, <code>PatternType</code>, or <code>Operation</code>). This is the only entity our API will revolve around, and here is how we can define some sample values:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Examples</span> </span>{
  <span class="hljs-keyword">val</span> validAcl1 = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>, <span class="hljs-string">"position-report"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">LITERAL</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"User:andrea"</span>, <span class="hljs-string">"example.cloud"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">ALL</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

  <span class="hljs-keyword">val</span> validAcl2 = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">CLUSTER</span>, <span class="hljs-string">"kafka-test-"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">PREFIXED</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"Group:testers"</span>, <span class="hljs-string">"example.cloud1"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">DESCRIBE</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

  <span class="hljs-keyword">val</span> invalidAcl = <span class="hljs-type">AclBinding</span>(<span class="hljs-type">ResourcePattern</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TRANSACTION_ID</span>, <span class="hljs-string">"*"</span>, <span class="hljs-type">PatternType</span>.<span class="hljs-type">LITERAL</span>), <span class="hljs-type">AclEntry</span>(<span class="hljs-string">"User:andrea"</span>, <span class="hljs-string">"cloud1"</span>, <span class="hljs-type">Operation</span>.<span class="hljs-type">ALTER</span>, <span class="hljs-type">PermissionType</span>.<span class="hljs-type">ALLOW</span>))

}
</code></pre>
<p>Now, let's move on to defining a REST endpoint to create a Kafka ACL!</p>
<h3><a class="anchor" aria-hidden="true" id="strongly-typed-endpoint-definitions"></a><a href="#strongly-typed-endpoint-definitions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strongly typed endpoint definitions</h3>
<p>In Tapir, REST endpoints are described as values of type <code>Endpoint[I, E, O, S]</code> where:</p>
<ul>
<li><code>I</code> is a <em>tuple</em> representing the various endpoint inputs (e.g. dynamic path fragments, query params, as well as its parsed request payload).</li>
<li><code>E</code> and <code>O</code> are output types for the error (e.g. 400 Bad Request) and the success (2xx) case.</li>
<li><code>S</code> is the type of streams that are used by the endpoint’s inputs/outputs. This is relevant only for more advanced use
cases such as defining <em>Server Sent Events</em> and Websocket endpoints, which we will not be covering in this post.</li>
</ul>
<p>In order to declare such complex type definitions, the library provides us with a builder syntax that allows us to incrementally declare our endpoint's
inlets and outlets bit by bit, with a high degree of precision:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.generic.auto._
<span class="hljs-keyword">import</span> sttp.tapir.json.circe._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">StatusCode</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEndpoints</span> </span>{
    <span class="hljs-keyword">val</span> createNewAcl: <span class="hljs-type">Endpoint</span>[(<span class="hljs-type">AuthToken</span>, <span class="hljs-type">AclBinding</span>), <span class="hljs-type">ApiError</span>, <span class="hljs-type">Unit</span>, <span class="hljs-type">Nothing</span>] = endpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(jsonBody[<span class="hljs-type">AclBinding</span>])
      .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))
}
</code></pre>
<p>There's quite a lot going on here already, so let's start unpacking it bit by bit:</p>
<p>We start building the endpoint using the constructor value <code>endpoint</code> of type <code>Enpoint[Unit, Unit, Unit, Nothing]</code>.
This acts as the entry point into the Tapir DSL. Using such syntax, we also specify that:</p>
<ul>
<li>Our endpoint's uses the http method <code>POST</code></li>
<li>it will be bound to the path <code>/api/kafka/acls</code></li>
<li>it will expect a header called <code>x-api-token</code> as well as a JSON request body (parsable as <code>AclBinding</code>) as its input</li>
<li>On success, it will respond with a status code of <code>201 Created</code> and an empty response payload.</li>
<li>On error, it will respond with the JSON representation of an <code>ApiError</code>.</li>
</ul>
<p>With our first endpoint defined in all its nitty gritty details, it's now time move on and implement the underlying logic.
But first, let's quickly flash out another endpoint to list the persisted Acls:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.generic.auto._
<span class="hljs-keyword">import</span> sttp.tapir.json.circe._
<span class="hljs-keyword">import</span> sttp.tapir.codec.enumeratum._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">StatusCode</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AclEndpoints</span> </span>{
    <span class="hljs-keyword">val</span> createNewAcl = endpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(jsonBody[<span class="hljs-type">AclBinding</span>].description(<span class="hljs-string">"The json representation of an ACL binding"</span>).example(<span class="hljs-type">Examples</span>.validAcl1))
      .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))


    <span class="hljs-keyword">val</span> listAllAcls = endpoint
      .get
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-api-token"</span>))
      .in(query[<span class="hljs-type">Option</span>[<span class="hljs-type">ResourceType</span>]](<span class="hljs-string">"resourceType"</span>)
           .description(<span class="hljs-string">"An optional ResourceType value to filter by"</span>)
           .example(<span class="hljs-type">Some</span>(<span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>)))
      .out(jsonBody[<span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]])
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="wiring-up-our-business-logic"></a><a href="#wiring-up-our-business-logic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wiring up our business logic</h3>
<p>As mentioned before, we plan on stubbing the persistence of our ACL bindings into a in-memory structure.
However, in order to do so we will still need to rely on a real HTTP server capable of handling incoming client
requests.</p>
<p>For this post, I have chosen to use <a href="https://http4s.org/">Http4s</a>, a library that allows to work with HTTP in a <em>purely functional</em> style.
Please do not run away if this is not your library of choice. As well as for Http4s, Tapir provides support for several other
Scala HTTP server implementations such us Akka-HTTP, Play, Finatra, and Vert.X.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.server.http4s._
<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> org.http4s.<span class="hljs-type">HttpRoutes</span>
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>}
<span class="hljs-keyword">import</span> cats.effect.concurrent.<span class="hljs-type">Ref</span>
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclRoutes</span>(<span class="hljs-params">aclStore: <span class="hljs-type">Ref</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">AclBinding</span>]]</span>)(<span class="hljs-params">implicit cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>], timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>]</span>) </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> createNewAcl: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] =
    <span class="hljs-type">AclEndpoints</span>.createNewAcl.toRoutes { <span class="hljs-keyword">case</span> (_, aclBinding) =&gt; 
       <span class="hljs-keyword">if</span> (!<span class="hljs-type">AclValidation</span>.isValid(aclBinding)) <span class="hljs-type">IO</span>.pure(<span class="hljs-type">Left</span>(<span class="hljs-type">AclValidation</span>.<span class="hljs-type">Error</span>))
       <span class="hljs-keyword">else</span> aclStore.update(_ + aclBinding).map(_ =&gt; <span class="hljs-type">Right</span>(()))
    }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> listAcls: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] =
    <span class="hljs-type">AclEndpoints</span>.listAllAcls.toRoutes { <span class="hljs-keyword">case</span> (_, maybeResourceType) =&gt; 
      <span class="hljs-keyword">val</span> matchesResourceType: <span class="hljs-type">AclBinding</span> =&gt; <span class="hljs-type">Boolean</span> = acl =&gt; maybeResourceType.fold(<span class="hljs-literal">true</span>)(acl.pattern.resourceType == _)
      aclStore.get.map(_.toList.filter(matchesResourceType).asRight[<span class="hljs-type">Unit</span>])
    }

  <span class="hljs-keyword">val</span> combined: <span class="hljs-type">HttpRoutes</span>[<span class="hljs-type">IO</span>] = createNewAcl &lt;+&gt; listAcls
}
</code></pre>
<p>To start with, notice the <code>sttp.tapir.server.http4s._</code> import. This brings in a bunch of implicit
classes that extend our <code>Endpoint[_,...]</code> with a <code>toRoutes</code> method. <code>toRoutes</code> <em>interprets</em> the Tapir
endpoint description into a <code>org.http4.HttpRoutes[IO]</code> (i.e. the actual HTTP server implementation).
Also, notice how the input, error and output types of the two routes are fully aligned with the ones of our endpoint
definitions. It is by this aliment mechanism that the library provides us with strong compile-time guarantees that
our implementation won't drift away from the generated docs, and that our system <em>will do exactly what it says on the tin</em>.</p>
<p>Let's now look at the two route implementations. In <code>createNewAcl</code>, we pass the parsed payload <code>aclBinding</code> as an input for <code>AclValidation.isValid</code>.
For simplicity, I am omitting the actual implementation of the <code>AclValidation</code> object. For the sake of example, let's say that <code>isValid</code> performs some simple logic to verify
that the supplied combination of our Acl's <code>ResourceType</code> and <code>Operation</code> is valid as per the <a href="https://docs.confluent.io/platform/current/kafka/authorization.html#operations">reference table</a>
in the Confluent docs. If the validation succeeds and a <code>Right(())</code> is returned, we
simply update our in memory store by adding the new acl binding. If the validation fails, we instead return
a <code>Left</code> wrapping an <code>ApiError</code> value.</p>
<p>The implementation of <code>listAcls</code> is equally simple. Here we read from our store, apply an optional <code>ResourceType</code> filter, and return the resulting set of acls as a list.
Unlike with the <code>createNewAcl</code>, we don't expect this endpoint to ever return a <code>Bad Request</code>, so we type its error as <code>Unit</code>.</p>
<p>Aside from reading and writing to the atomic reference <code>aclStore</code>, our ACL handling code here is pretty much pure and side-effect free. However,
Tapir models the logic used to interpret the endpoint into an actual route as a function of the following shape: <code>I =&gt; IO[Either[E, O]</code>, or more generically <code>I =&gt; F[Either[E, O]</code>.
This makes sense, as most read world API endpoints perform some sort of effectful computation such us opening sockets, interacting with a datastore, or reading/writing to disk.</p>
<h3><a class="anchor" aria-hidden="true" id="authentication-and-other-common-route-logic"></a><a href="#authentication-and-other-common-route-logic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Authentication and other common route logic</h3>
<p>While in the endpoint definitions above we do specify an <code>x-api-token</code> header, you might have noticed that we haven't yet
implemented any logic around this mandatory input. As it currently stands, our server logic is in fact completely insecure, and we should probably do something about it!</p>
<p>One simple way to approach this would be to implement an authentication helper function like the following and reuse it across all the endpoints we want to secure:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">userOrApiError</span></span>[<span class="hljs-type">A</span>](token: <span class="hljs-type">ApiToken</span>)(logic: <span class="hljs-type">User</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[]]): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">A</span>]]
</code></pre>
<p>For instance, we would extend the <code>createNewAcl</code> route as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">AclEndpoints</span>.createNewAcl.toRoutes { <span class="hljs-keyword">case</span> (apiToken, aclBinding) =&gt; 
   userOrApiError(apiToken) { user =&gt;
     <span class="hljs-keyword">if</span> (!<span class="hljs-type">AclValidation</span>.isValid(aclBinding)) <span class="hljs-type">IO</span>.pure(<span class="hljs-type">Left</span>(<span class="hljs-type">AclValidation</span>.<span class="hljs-type">Error</span>))
     <span class="hljs-keyword">else</span> aclStore.update(_ + aclBinding).map(_ =&gt; <span class="hljs-type">Right</span>(()))
   }
}
</code></pre>
<p>This might look okay in a small code-base like ours, but it will probably not fly on a large
one, as the boilerplate and the nesting of helper functions like <code>userOrApiError</code> will increase as
our cross-cutting concerns become more complex and involved.</p>
<p>Luckily for us, the authors of Tapir have recently come up with a nicer pattern to handle common logic such as
authentication and authorisation. This revolves around the notion of partially defined endpoints which can combine
an input/output description with some server logic:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SecureAclEndpoints</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auth</span></span>(token: <span class="hljs-type">AuthToken</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">User</span>]] = <span class="hljs-type">IO</span>.pure {
    <span class="hljs-keyword">if</span> (token == <span class="hljs-string">"let-me-in!"</span>) <span class="hljs-type">Right</span>(<span class="hljs-type">User</span>(<span class="hljs-string">"legit"</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-type">Left</span>(<span class="hljs-type">ApiError</span>(<span class="hljs-string">"Forbidden"</span>))
  }
  
  <span class="hljs-keyword">val</span> secureEndpoint = endpoint
    .in(header[<span class="hljs-type">AuthToken</span>](<span class="hljs-string">"x-auth-token"</span>))
    .errorOut(jsonBody[<span class="hljs-type">ApiError</span>])
    .serverLogicForCurrent(auth)
}
</code></pre>
<p>Both the endpoint definition and the server logic in <code>secureEndpoint</code> can now be neatly composed into other
definitions:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> createNewAcl = <span class="hljs-type">SecureAclEndpoints</span>
      .secureEndpoint
      .post
      .in(<span class="hljs-string">"api"</span> / <span class="hljs-string">"kafka"</span> / <span class="hljs-string">"acls"</span>)
      .in(jsonBody[<span class="hljs-type">AclBinding</span>])
      .out(statusCode(<span class="hljs-type">StatusCode</span>.<span class="hljs-type">Created</span>))
<span class="hljs-comment">// createNewAcl: server.PartialServerEndpoint[User, AclBinding, ApiError, typelevel.LowPriorityTupleConcat0.&lt;refinement&gt;.this.type.Out, Any, IO] = sttp.tapir.server.PartialServerEndpoint$$anon$1@6617a</span>
</code></pre>
<p>For more details on partial endpoints and other ways in which Tapir allows to abstract common logic, please refer to the
the <a href="https://tapir.softwaremill.com/en/v0.16.16/server/logic.html">Server Logic</a> section of the official docs.</p>
<h3><a class="anchor" aria-hidden="true" id="hitting-our-endpoints"></a><a href="#hitting-our-endpoints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hitting our endpoints</h3>
<p>Okay, so we have a couple of endpoints defined and implemented. Now we should probably check that they work as expected.
One way to do so without having to bind an actual web server to a port is to use Http4s DSL and hit our routes programmatically, as we would do in a simple unit test covering only the route logic.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> cats.effect.concurrent.<span class="hljs-type">Ref</span>
<span class="hljs-keyword">import</span> org.http4s.<span class="hljs-type">HttpRoutes</span>
<span class="hljs-keyword">import</span> org.http4s.dsl.io._
<span class="hljs-keyword">import</span> org.http4s.headers._
<span class="hljs-keyword">import</span> org.http4s._
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>}
<span class="hljs-keyword">import</span> org.http4s.circe._
<span class="hljs-keyword">import</span> org.http4s.implicits._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] =
  <span class="hljs-type">IO</span>.contextShift(scala.concurrent.<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> t: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>] =
  <span class="hljs-type">IO</span>.timer(scala.concurrent.<span class="hljs-type">ExecutionContext</span>.global)  

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> aclEntityEncoder = jsonEncoderOf[<span class="hljs-type">IO</span>, <span class="hljs-type">AclBinding</span>]
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> aclEntityDecoder = jsonOf[<span class="hljs-type">IO</span>, <span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]]
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> apiEntityDecoder = jsonOf[<span class="hljs-type">IO</span>, <span class="hljs-type">ApiError</span>]

<span class="hljs-keyword">val</span> apiToken = <span class="hljs-type">Header</span>(<span class="hljs-string">"x-api-token"</span>, <span class="hljs-string">"let-me-in!"</span>)
<span class="hljs-keyword">val</span> endpointUrl = <span class="hljs-type">Uri</span>.unsafeFromString(<span class="hljs-string">"/api/kafka/acls"</span>)

<span class="hljs-keyword">val</span> store = <span class="hljs-type">Ref</span>.unsafe[<span class="hljs-type">IO</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">AclBinding</span>]](<span class="hljs-type">Set</span>.empty)
<span class="hljs-keyword">val</span> routes = <span class="hljs-keyword">new</span> <span class="hljs-type">AclRoutes</span>(store).combined.orNotFound
</code></pre>
<p>Here we just setup the boilerplate needed to run some HTTP request through our web service:
We initialise a store and the <code>AclRoutes</code>, and then we compose the two routes
above into a single http service which will fallback to a 404 response should it fail to match
the incoming request. With some help from the http4s DSL, we can now fire a few requests
at our endpoints!</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">//create a valid ACL binding</span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">POST</span>, endpointUrl)
    .withHeaders(apiToken)
    .withEntity(<span class="hljs-type">Examples</span>.validAcl1)
).map(_.status).unsafeRunSync()
<span class="hljs-comment">// res0: Status = Status(code = 201)</span>

<span class="hljs-comment">//try to submit an invalid one</span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">POST</span>, endpointUrl)
    .withHeaders(apiToken)
    .withEntity(<span class="hljs-type">Examples</span>.invalidAcl)
).flatMap(resp =&gt; resp.as[<span class="hljs-type">ApiError</span>].map(_ -&gt; resp.status)).unsafeRunSync()
<span class="hljs-comment">// res1: (ApiError, Status) = (</span>
<span class="hljs-comment">//   ApiError(error = "The supplied ACL binding is invalid"),</span>
<span class="hljs-comment">//   Status(code = 400)</span>
<span class="hljs-comment">// )</span>

<span class="hljs-comment">//Get the acl list </span>
routes(
  <span class="hljs-type">Request</span>[<span class="hljs-type">IO</span>](method = <span class="hljs-type">Method</span>.<span class="hljs-type">GET</span>, endpointUrl.withQueryParam(<span class="hljs-string">"resourceType"</span>, <span class="hljs-type">ResourceType</span>.<span class="hljs-type">TOPIC</span>.entryName))
    .withHeaders(apiToken)
).flatMap(_.as[<span class="hljs-type">List</span>[<span class="hljs-type">AclBinding</span>]]).unsafeRunSync()
<span class="hljs-comment">// res2: List[AclBinding] = List(</span>
<span class="hljs-comment">//   AclBinding(</span>
<span class="hljs-comment">//     pattern = ResourcePattern(</span>
<span class="hljs-comment">//       resourceType = TOPIC,</span>
<span class="hljs-comment">//       resource = "position-report",</span>
<span class="hljs-comment">//       patternType = LITERAL</span>
<span class="hljs-comment">//     ),</span>
<span class="hljs-comment">//     entry = AclEntry(</span>
<span class="hljs-comment">//       principal = "User:andrea",</span>
<span class="hljs-comment">//       host = "example.cloud",</span>
<span class="hljs-comment">//       operation = ALL,</span>
<span class="hljs-comment">//       permissionType = ALLOW</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Hurray! Our endpoints seem to work as expected.</p>
<h3><a class="anchor" aria-hidden="true" id="interpreting-into-an-openapi-spec"></a><a href="#interpreting-into-an-openapi-spec" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interpreting into an OpenAPI spec</h3>
<p>With both endpoint declaration, implementation and testing covered, we are finally ready to look into
how Tapir helps us writing and maintaining high quality API docs. This is surprisingly straightforward
as it only involves grouping our endpoint definitions into a sequence and use a simple DSL to build an OpenAPI
spec: a machine readable specification detailing all the relevant attributes of our endpoints, from the query parameters
to the JSON schema of the request/response payloads.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir._
<span class="hljs-keyword">import</span> sttp.tapir.openapi.<span class="hljs-type">OpenAPI</span>
<span class="hljs-keyword">import</span> sttp.tapir.docs.openapi._

<span class="hljs-keyword">val</span> openAPISpec = <span class="hljs-type">List</span>(
  <span class="hljs-type">AclEndpoints</span>.createNewAcl,
  <span class="hljs-type">AclEndpoints</span>.listAllAcls
).toOpenAPI(<span class="hljs-string">"REST Kafka ACLs"</span>, <span class="hljs-string">"1.0"</span>)
<span class="hljs-comment">// openAPISpec: OpenAPI = OpenAPI(</span>
<span class="hljs-comment">//   openapi = "3.0.3",</span>
<span class="hljs-comment">//   info = Info(</span>
<span class="hljs-comment">//     title = "REST Kafka ACLs",</span>
<span class="hljs-comment">//     version = "1.0",</span>
<span class="hljs-comment">//     description = None,</span>
<span class="hljs-comment">//     termsOfService = None,</span>
<span class="hljs-comment">//     contact = None,</span>
<span class="hljs-comment">//     license = None</span>
<span class="hljs-comment">//   ),</span>
<span class="hljs-comment">//   tags = List(),</span>
<span class="hljs-comment">//   servers = List(),</span>
<span class="hljs-comment">//   paths = ListMap(</span>
<span class="hljs-comment">//     "/api/kafka/acls" -&gt; PathItem(</span>
<span class="hljs-comment">//       summary = None,</span>
<span class="hljs-comment">//       description = None,</span>
<span class="hljs-comment">//       get = Some(</span>
<span class="hljs-comment">//         value = Operation(</span>
<span class="hljs-comment">//           tags = List(),</span>
<span class="hljs-comment">//           summary = None,</span>
<span class="hljs-comment">//           description = None,</span>
<span class="hljs-comment">//           operationId = "getApiKafkaAcls",</span>
<span class="hljs-comment">//           parameters = List(</span>
<span class="hljs-comment">//             Right(</span>
<span class="hljs-comment">//               value = Parameter(</span>
<span class="hljs-comment">//                 name = "x-api-token",</span>
<span class="hljs-comment">//                 in = header,</span>
<span class="hljs-comment">//                 description = None,</span>
<span class="hljs-comment">//                 required = Some(value = true),</span>
<span class="hljs-comment">//                 deprecated = None,</span>
<span class="hljs-comment">//                 allowEmptyValue = None,</span>
<span class="hljs-comment">//                 style = None,</span>
<span class="hljs-comment">//                 explode = None,</span>
<span class="hljs-comment">//                 allowReserved = None,</span>
<span class="hljs-comment">//                 schema = Right(</span>
<span class="hljs-comment">//                   value = Schema(</span>
<span class="hljs-comment">//                     allOf = List(),</span>
<span class="hljs-comment">//                     title = None,</span>
<span class="hljs-comment">//                     required = List(),</span>
<span class="hljs-comment">//                     type = Some(value = string),</span>
<span class="hljs-comment">//                     items = None,</span>
<span class="hljs-comment">//                     properties = ListMap(),</span>
<span class="hljs-comment">//                     description = None,</span>
<span class="hljs-comment">//                     format = None,</span>
<span class="hljs-comment">//                     default = None,</span>
<span class="hljs-comment">//                     nullable = None,</span>
<span class="hljs-comment">//                     readOnly = None,</span>
<span class="hljs-comment">//                     writeOnly = None,</span>
<span class="hljs-comment">//                     example = None,</span>
<span class="hljs-comment">// ...</span>
</code></pre>
<p>Notice that the value returned by <code>toOpenAPI</code> is a syntax tree modelling an OpenAPI spec. Once computed,
this syntax tree can be modified and extended using plain Scala functions. Most of the times, this is something you will
not need doing, but it can provide a good escape hatch should you need to produce OpenAPI specs in a way that for some reason
Tapir doesn't support.</p>
<p>As a final step, you will probably want to serialise the spec into YAML so that it can be exported or served to the browser
as an HTTP response:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir.openapi.circe.yaml._

println(openAPISpec.toYaml)
<span class="hljs-comment">// openapi: 3.0.3</span>
<span class="hljs-comment">// info:</span>
<span class="hljs-comment">//   title: REST Kafka ACLs</span>
<span class="hljs-comment">//   version: '1.0'</span>
<span class="hljs-comment">// paths:</span>
<span class="hljs-comment">//   /api/kafka/acls:</span>
<span class="hljs-comment">//     get:</span>
<span class="hljs-comment">//       operationId: getApiKafkaAcls</span>
<span class="hljs-comment">//       parameters:</span>
<span class="hljs-comment">//       - name: x-api-token</span>
<span class="hljs-comment">//         in: header</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//       - name: resourceType</span>
<span class="hljs-comment">//         in: query</span>
<span class="hljs-comment">//         description: An optional ResourceType value to filter by</span>
<span class="hljs-comment">//         required: false</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - CLUSTER</span>
<span class="hljs-comment">//           - DELEGATION_TOKEN</span>
<span class="hljs-comment">//           - GROUP</span>
<span class="hljs-comment">//           - TOPIC</span>
<span class="hljs-comment">//           - TRANSACTION_ID</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//         example: TOPIC</span>
<span class="hljs-comment">//       responses:</span>
<span class="hljs-comment">//         '200':</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//           content:</span>
<span class="hljs-comment">//             application/json:</span>
<span class="hljs-comment">//               schema:</span>
<span class="hljs-comment">//                 type: array</span>
<span class="hljs-comment">//                 items:</span>
<span class="hljs-comment">//                   $ref: '#/components/schemas/AclBinding'</span>
<span class="hljs-comment">//     post:</span>
<span class="hljs-comment">//       operationId: postApiKafkaAcls</span>
<span class="hljs-comment">//       parameters:</span>
<span class="hljs-comment">//       - name: x-api-token</span>
<span class="hljs-comment">//         in: header</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//         schema:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//       requestBody:</span>
<span class="hljs-comment">//         description: The json representation of an ACL binding</span>
<span class="hljs-comment">//         content:</span>
<span class="hljs-comment">//           application/json:</span>
<span class="hljs-comment">//             schema:</span>
<span class="hljs-comment">//               $ref: '#/components/schemas/AclBinding'</span>
<span class="hljs-comment">//             example:</span>
<span class="hljs-comment">//               pattern:</span>
<span class="hljs-comment">//                 resourceType: TOPIC</span>
<span class="hljs-comment">//                 resource: position-report</span>
<span class="hljs-comment">//                 patternType: LITERAL</span>
<span class="hljs-comment">//               entry:</span>
<span class="hljs-comment">//                 principal: User:andrea</span>
<span class="hljs-comment">//                 host: example.cloud</span>
<span class="hljs-comment">//                 operation: ALL</span>
<span class="hljs-comment">//                 permissionType: ALLOW</span>
<span class="hljs-comment">//         required: true</span>
<span class="hljs-comment">//       responses:</span>
<span class="hljs-comment">//         '201':</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//         default:</span>
<span class="hljs-comment">//           description: ''</span>
<span class="hljs-comment">//           content:</span>
<span class="hljs-comment">//             application/json:</span>
<span class="hljs-comment">//               schema:</span>
<span class="hljs-comment">//                 $ref: '#/components/schemas/ApiError'</span>
<span class="hljs-comment">// components:</span>
<span class="hljs-comment">//   schemas:</span>
<span class="hljs-comment">//     AclBinding:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - pattern</span>
<span class="hljs-comment">//       - entry</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         pattern:</span>
<span class="hljs-comment">//           $ref: '#/components/schemas/ResourcePattern'</span>
<span class="hljs-comment">//         entry:</span>
<span class="hljs-comment">//           $ref: '#/components/schemas/AclEntry'</span>
<span class="hljs-comment">//     ResourcePattern:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - resourceType</span>
<span class="hljs-comment">//       - resource</span>
<span class="hljs-comment">//       - patternType</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         resourceType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - CLUSTER</span>
<span class="hljs-comment">//           - DELEGATION_TOKEN</span>
<span class="hljs-comment">//           - GROUP</span>
<span class="hljs-comment">//           - TOPIC</span>
<span class="hljs-comment">//           - TRANSACTION_ID</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//         resource:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         patternType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - LITERAL</span>
<span class="hljs-comment">//           - MATCH</span>
<span class="hljs-comment">//           - PREFIXED</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//     AclEntry:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - principal</span>
<span class="hljs-comment">//       - host</span>
<span class="hljs-comment">//       - operation</span>
<span class="hljs-comment">//       - permissionType</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         principal:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         host:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//         operation:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - ALL</span>
<span class="hljs-comment">//           - ALTER</span>
<span class="hljs-comment">//           - ALTER_CONFIGS</span>
<span class="hljs-comment">//           - CLUSTER_ACTION</span>
<span class="hljs-comment">//           - CREATE</span>
<span class="hljs-comment">//           - DELETE</span>
<span class="hljs-comment">//           - DESCRIBE</span>
<span class="hljs-comment">//           - DESCRIBE_CONFIGS</span>
<span class="hljs-comment">//           - IDEMPOTENT_WRITE</span>
<span class="hljs-comment">//           - READ</span>
<span class="hljs-comment">//           - UNKNOWN</span>
<span class="hljs-comment">//           - WRITE</span>
<span class="hljs-comment">//         permissionType:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//           enum:</span>
<span class="hljs-comment">//           - ALLOW</span>
<span class="hljs-comment">//           - DENY</span>
<span class="hljs-comment">//     ApiError:</span>
<span class="hljs-comment">//       required:</span>
<span class="hljs-comment">//       - error</span>
<span class="hljs-comment">//       type: object</span>
<span class="hljs-comment">//       properties:</span>
<span class="hljs-comment">//         error:</span>
<span class="hljs-comment">//           type: string</span>
<span class="hljs-comment">//</span>
</code></pre>
<p>As a format, OpenAPI is agnostic of its presentation. However, several web-based UI tools exist to browse and interact with
OpenAPI specs. This is how our endpoints look like when viewed in <a href="https://editor.swagger.io/">SwaggerUI</a>, one of the most popular OpenAPI viewer:</p>
<p><img src="https://ibin.co/w800/5jSShLatLQ7N.png" alt="endpoints see SwaggerUI"></p>
<h3><a class="anchor" aria-hidden="true" id="interpreting-into-an-api-client"></a><a href="#interpreting-into-an-api-client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interpreting into an API client</h3>
<p>Automatically generating API docs from our endpoint definitions is great, but it doesn't have to end there; we can be more ambitious and automate more aggressively!
As well as an OpenAPI spec, Tapir can also <em>interpret</em> an endpoint definition into a fully functioning API client:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> sttp.tapir.client.sttp._
<span class="hljs-keyword">import</span> sttp.client3._
<span class="hljs-keyword">import</span> sttp.model.<span class="hljs-type">Uri</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclClient</span>(<span class="hljs-params">apiBaseUrl: <span class="hljs-type">Uri</span>, apiToken: <span class="hljs-type">String</span></span>) </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> backend: <span class="hljs-type">SttpBackend</span>[<span class="hljs-type">Identity</span>, <span class="hljs-type">Any</span>] = <span class="hljs-type">HttpURLConnectionBackend</span>()

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createNewAcl</span></span>(aclBinding: <span class="hljs-type">AclBinding</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">ApiError</span>, <span class="hljs-type">Unit</span>]] = {
     <span class="hljs-keyword">val</span> endpointInput = (apiToken, aclBinding)
     <span class="hljs-keyword">val</span> request = <span class="hljs-type">AclEndpoints</span>.createNewAcl.toSttpRequestUnsafe(apiBaseUrl).apply(endpointInput)
     <span class="hljs-type">IO</span>(request.send(backend).body)
   }
}
</code></pre>
<p>The snippet above illustrates how to use Tapir to generate HTTP requests for the <a href="https://tapir.softwaremill.com/en/latest/client/sttp.html">Sttp</a> client. The <code>toSttpRequestUnsafe</code>
function brought in by the <code>sttp.tapir.client.sttp</code> import, takes in two parameters:</p>
<ul>
<li>A <code>baseUrl</code> for our API server</li>
<li>The endpoint inputs, as specified in the above definition (in this example, a <code>Touple2</code> containing the api key and the supplied ACL binding).</li>
</ul>
<p>Compared to our previous snippet, where we hit our endpoints using the Http4s DSL, this approach has some significant advantages:
the generated Tapir API client neatly abstracts away the details of the HTTP implementation as well as the serialisation format, exposing only a function that maps our API inputs to its outputs.</p>
<p>Arguably, working at this level of abstraction is for most engineers preferable than having to be
bogged down into the details of hand-wiring HTTP requests. Moreover, it is also safer, as it rules out a
whole class of trivial and yet very frequent programming errors (e.g. misspelling the API key header, omitting part of the
ACL JSON payload, etc) while reducing the likelihood for the client implementation to go out of sync with the server.</p>
<h3><a class="anchor" aria-hidden="true" id="conclusions"></a><a href="#conclusions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusions</h3>
<p>In this post, I have tried to demonstrate Tapir's main features by working through the implementation of a REST API
for creating and listing Kafka ACLs. We saw how endpoint definitions, expressed as Scala types, can drive the
implementation of both server side logic while at the same time automatically generate up-to-date
API docs, as well as fully functioning API clients.</p>
<p>Now, before you set off to introduce Tapir in your production code-base, please let me also share a few words of warning:</p>
<p>Firstly, despite its increasingly rich set of features and integrations, keep in mind that Tapir is still a relatively
young project with only a couple of years of active development under his belt. While it is definitely reaching maturity,
I would still expect its API to occasionally introduce some breaking changes, which might make it harder to retrofit
into a large existing project.</p>
<p>Secondly, like with every software framework, do keep in mind that all the good automation and safety that Tapir brings
about comes at a cost. You will have to face a slightly higher degree of indirection, as the library centralises
control over settings and behaviours that you would otherwise be able to control on a single route/endpoint basis
(e.g. handling of unparsable input payloads, handling of exceptions, etc).</p>
<p>Also, be prepared to dive into some deep Scala rabbit holes, as Tapir leverages advanced features of the language
such as type-level programming, type-class derivation, macros, etc. In other words, this is something you probably want to
stay clear from if you are still familiarising with the language.</p>
<p>That said, if you are not put off by either of the above, this might be a price worth paying in exchange for a higher
degree of API integration, automation and consistency. I hope I have shared with you some of my enthusiasm for this excellent
library, as I genuinely believe it makes building complex, API driven systems at scale easier and safer to
a remarkable extent.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/website/blog/2020/02/15/discarding-io">Discarded effects: a common pitfall when working with Scala IO monads</a></h1><p class="post-meta">February 15, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="http://twitter.com/afiore" target="_blank" rel="noreferrer noopener">Andrea Fiore</a></p></div></header><article class="post-content"><div><span><p>One thing that I would be certainly missing if I was to drop Scala in favor of another programming language is a
mechanism to suspend the execution of side effects.</p>
<p>This programming technique is available in Scala thanks to the popular <a href="https://typelevel.org/cats-effect/">Cats Effects</a> library
as well some other alternative implementations such as <a href="https://monix.io/">Monix</a> or <a href="https://zio.dev/">ZIO</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="why-using-an-effect-system"></a><a href="#why-using-an-effect-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why using an effect system</h2>
<p>I find myself reaching out to Cats' IO monad for two main reasons:</p>
<ul>
<li><p><em>It allows to clearly tell apart the bits of program logic that perform side effects from the ones that do not</em>
(e.g. issuing an RPC call vs sorting the items of a list). I find this reassuring: I am aware that I cannot be
fully in control of the former, as they involve interactions with the world outside my program. However, I know that,
as long as I don't break <a href="https://wiki.haskell.org/Referential_transparency">referential transparency</a>, the latter
will be fully deterministic and therefore easier to manage and reason about.</p></li>
<li><p><em>IO provides a means to manipulate side effecting code using the same high order functions</em> one gets accustomed to while
working with Scala collections methods  (e.g. map, flatMap, foldLeft, traverse, etc).</p></li>
</ul>
<p>While embracing this programming style, it is important to be aware of a quirk of Scala known as <em>value discarding</em>.
In this post, I will illustrate how this conversion rule, applied by default by the Scala compiler, might cause your code
to behave unexpectedly. Such misbehaviour might equally affect your program as it runs in production as well as it
gets tested in CI. I will point at an easy way to avoid this pitfall by tweaking the compiler flags, thus turning potentially nasty
runtime bugs into compile time errors.</p>
<h2><a class="anchor" aria-hidden="true" id="the-pitfall-discarded-effects"></a><a href="#the-pitfall-discarded-effects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The pitfall: discarded effects</h2>
<p><img src="/website/img/posts/xkcd-haskell.png" alt="xkcd haskell comic"></p>
<p>Suppose we are working on some simple CRUD functionality and you have refactored your persistence code as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DAO1</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DAO1</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup</span></span>(xa: <span class="hljs-type">Transactor</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">DAO1</span>] = <span class="hljs-type">IO</span> {
    println(<span class="hljs-string">"running pretend DB migrations for DAO1 ..."</span>)
    <span class="hljs-keyword">new</span> <span class="hljs-type">DAO1</span>
  }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DAO2</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DAO2</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup</span></span>(xa: <span class="hljs-type">Transactor</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">DAO2</span>] = <span class="hljs-type">IO</span> {
    println(<span class="hljs-string">"running pretend DB migrations for DAO2 ..."</span>)
    <span class="hljs-keyword">new</span> <span class="hljs-type">DAO2</span>
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DAO3</span>(<span class="hljs-params">dao1: <span class="hljs-type">DAO1</span>, dao2: <span class="hljs-type">DAO2</span></span>)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withDAO</span></span>(dbAction: <span class="hljs-type">DAO3</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>]): <span class="hljs-type">Unit</span> =
  withTransactor { xa =&gt;
    <span class="hljs-keyword">for</span> {
      dao1 &lt;- <span class="hljs-type">DAO1</span>.setup(xa)
      dao2 &lt;- <span class="hljs-type">DAO2</span>.setup(xa)
    } <span class="hljs-keyword">yield</span> dbAction(<span class="hljs-keyword">new</span> <span class="hljs-type">DAO3</span>(dao1, dao2))
  }.unsafeRunSync()

withDAO { dao =&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">s"using DAO: <span class="hljs-subst">$dao</span>"</span>)) }
<span class="hljs-comment">// running pretend DB migrations for DAO1 ...</span>
<span class="hljs-comment">// running pretend DB migrations for DAO2 ...</span>
</code></pre>
<p>Let's break this snippet apart:</p>
<ul>
<li><code>withTransactor</code> is a function that establishes a database connection,
performs a supplied IO within a transaction, and then safely disposes of the connection.
It's signature is:</li>
</ul>
<pre><code class="hljs css language-scala">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withTransactor</span></span>[<span class="hljs-type">T</span>](f: <span class="hljs-type">Transactor</span>[<span class="hljs-type">IO</span>] =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">T</span>])
     : <span class="hljs-type">IO</span>[<span class="hljs-type">T</span>]
</code></pre>
<ul>
<li>We pass in to <code>withTransactor</code> an effectfull function. This initialises two <em>data access objects</em> by running their associated
db migrations, instantiates DAO3, and finally applies to it the supplied <code>dbAction</code> function.</li>
</ul>
<p>However, <em>there is something fishy in this code</em>! While all the <code>setup</code> calls in the for comprehension desugar
into a sequence of <code>flatMap</code> calls, the final call to <code>runAction</code> which we yield is translated into a call to the <code>map</code> method.</p>
<p>This results in an expression of type <code>IO[IO[Unit]]</code>, which in itself doesn't align with the return type stated in
<code>withTransactor</code>'s signature, and yet compiles just fine.</p>
<p>Enter value discarding. As concisely stated in <a href="https://scala-lang.org/files/archive/spec/2.12/06-expressions.html#value-conversions">section 6.26.1</a>
of the Scala language specification, value discarding is an <em>&quot;implicit conversion&quot;</em> that can be applied to <em>&quot;an expression
which is type checked with some expected type&quot;</em>.</p>
<blockquote>
<p>If e has some value type and the expected type is Unit, e is converted to the expected type by embedding it in the term { e; () }.</p>
</blockquote>
<p>This rule was probably intended as an ergonomic touch to make the compiler a bit smarter and less pedantic.
However, I would argue that here it is working against the programmer, as what gets discarded and never executed is
likely to be some important part of our program logic.</p>
<h2><a class="anchor" aria-hidden="true" id="compiler-flags-to-the-rescue"></a><a href="#compiler-flags-to-the-rescue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiler flags to the rescue</h2>
<p>Despite it does not provide a proper way to disable this conversion rule all together, the Scala 2 compiler can be easily configured
to be more strict with regard to value discarding. When used in combination with <code>-Xfatal-warning</code>, setting the <code>-Ywarn-value-discard</code>
flag will result in a compilation error. In the case of the snippet above, we would have encountered the following (fatal) warning:</p>
<pre><code class="hljs css language-scala">[error] example.scala:<span class="hljs-number">12</span> discarded non-<span class="hljs-type">Unit</span> value
</code></pre>
<p>As a reminder, this is the relevant Sbt setting to set these flags:</p>
<pre><code class="hljs css language-scala">scalacOptions ++= <span class="hljs-type">Seq</span>(
  <span class="hljs-string">"-Ywarn-value-discard"</span>,
  <span class="hljs-string">"-Xfatal-warnings"</span>
)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="discarded-assertions"></a><a href="#discarded-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Discarded assertions</h2>
<p>In fairness, one could argue that this pitfall could have been easily detected with some basic test coverage in place.</p>
<p>A test asserting that whatever effect our IO performs has actually occurred would have spotted this.
However, this is true only as long as our testing logic is actually executed and does not get discarded by the compiler.</p>
<p>As an example, let's take the previous snippet and bring it the context of a unit test.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> org.scalatest.{<span class="hljs-type">Matchers</span>, <span class="hljs-type">FlatSpec</span>}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardingTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Matchers</span> </span>{
  <span class="hljs-string">"DAO4"</span> should <span class="hljs-string">"persist a record"</span> in {
     withDAO4 { dao =&gt;
       <span class="hljs-keyword">for</span> {
         _ &lt;- dao.persist(<span class="hljs-keyword">new</span> <span class="hljs-type">Record</span>)
         persisted &lt;- dao.persisted
       } <span class="hljs-keyword">yield</span> persisted.nonEmpty shouldBe <span class="hljs-literal">true</span>
     }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withDAO4</span></span>(dbAction: <span class="hljs-type">DAO4</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>]): <span class="hljs-type">Unit</span> =
    withTransactor { xa =&gt;
      <span class="hljs-keyword">for</span> {
        dao1 &lt;- <span class="hljs-type">DAO1</span>.setup(xa)
        dao2 &lt;- <span class="hljs-type">DAO2</span>.setup(xa)
        records &lt;- <span class="hljs-type">Ref</span>[<span class="hljs-type">IO</span>].of(<span class="hljs-type">List</span>.empty[<span class="hljs-type">Record</span>])
      } <span class="hljs-keyword">yield</span> dbAction(<span class="hljs-keyword">new</span> <span class="hljs-type">DAO4</span>(dao1, dao2, records))
    }.unsafeRunSync()
}

<span class="hljs-comment">//buggy DAO4 implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DAO4</span>(<span class="hljs-params">dao1: <span class="hljs-type">DAO1</span>, dao2: <span class="hljs-type">DAO2</span>, records: <span class="hljs-type">Ref</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Record</span>]]</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">persist</span></span>(record: <span class="hljs-type">Record</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-keyword">for</span> {
    _ &lt;- <span class="hljs-type">IO</span>.raiseError( <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(<span class="hljs-string">"This exception might be discarded!"</span>))
    _ &lt;- records.update(_ :+ record)
  } <span class="hljs-keyword">yield</span> ()

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">persisted</span></span>: <span class="hljs-type">IO</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Record</span>]] = records.get
}
</code></pre>
<p><code>withDAO4</code> is a helper method intended to facilitate testing our persistence logic. This time, the IO function we pass in as
argument will do the following:</p>
<ul>
<li><code>persist</code> a record.</li>
<li>sequence a second IO call returning the list of persisted records.</li>
<li>asserts that the returned value is not an empty collection.</li>
</ul>
<p>But what happens when we actually run the test above?</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> org.scalatest._

durations.stats.nocolor.run(<span class="hljs-keyword">new</span> <span class="hljs-type">DiscardingTest</span>)
<span class="hljs-comment">// Run starting. Expected test count is: 1</span>
<span class="hljs-comment">// MdocSession$App$DiscardingTest$1:</span>
<span class="hljs-comment">// DAO4</span>
<span class="hljs-comment">// running pretend DB migrations for DAO1 ...</span>
<span class="hljs-comment">// running pretend DB migrations for DAO2 ...</span>
<span class="hljs-comment">// - should persist a record (16 milliseconds)</span>
<span class="hljs-comment">// Run completed in 47 milliseconds.</span>
<span class="hljs-comment">// Total number of tests run: 1</span>
<span class="hljs-comment">// Suites: completed 1, aborted 0</span>
<span class="hljs-comment">// Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0</span>
<span class="hljs-comment">// All tests passed.</span>
</code></pre>
<p>From bad to worse: not only our <code>dbAction</code> is discarded, but Scalatest happily reports that our test succeeded!</p>
<p>I have not spent time figuring out properly the mechanics whereby the library determines this outcome. From the outside, it seems like it is
taking an optimistic approach and deems a test successful unless at least one of its assertions fail.</p>
<h2><a class="anchor" aria-hidden="true" id="conclusions-avoid-a-double-facepalm"></a><a href="#conclusions-avoid-a-double-facepalm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusions: avoid a double facepalm!</h2>
<p><img src="/website/img/posts/double-facepalm.jpg" alt="double facepalm meme"></p>
<p>I have become aware of value discarding a while back, through an <a href="https://underscore.io/blog/posts/2016/11/24/value-discard.html">excellent post</a>
by Richard Dallaway. A few years later, this arguably strange behaviour is still the default for both Scala2 and Dotty.
Promisingly, a <a href="https://contributors.scala-lang.org/t/pre-sip-limiting-value-discards/3729">pre-SIP</a> has been recently put forward
to make the mechanism fully explicit, or configurable on a whitelist basis.
Hopefully this this proposal will get some traction and ultimately lead to a more sensible default for this feature.</p>
<p>Retrospectively, I can say that I have fell for this pitfall at least twice, and in both cases the discarded effect
in my test code was hiding an actual bug in the implementation (a true <em>double facepalm</em> moment!).</p>
<p>As a recommendation to fellow functional programmers picking up Cats effects and similar, I would definitely suggest
spending time learning about the available <a href="https://docs.scala-lang.org/overviews/compiler-options/index.html#Warning_Settings">compiler flags</a>,
and how they might be leveraged to make your build safer and sharper. Unless it is really not viable to do so,
making warnings fatal is 99% of the times a good idea, especially if you are working on a relatively small
and new code-base.</p>
<p>The other, perhaps bit more obvious piece of wisdom I feel like sharing (also as a note to self), is to never
trust blindly a green Scalatest suite. It is always a good idea to satisfy yourself that your assertions fail when you explicitly
break your implementation. While I learn more on how to best <a href="https://en.wikipedia.org/wiki/Mutation_testing">automate this process</a>,
ensuring that this verification is carried out will be a matter of discipline and habit.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020 Your Name or Your Company Name</section></footer></div></body></html>